<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<title>better-dom Source: Node.events.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	
	<link type="text/css" rel="stylesheet" href="styles/site.spacelab.css">
	
</head>

<body>
<div class="container-fluid">
	<div class="navbar navbar-fixed-top ">
		<div class="navbar-inner">
			<a class="brand" href="index.html">better-dom</a>
			<ul class="nav">
				
				<li class="dropdown">
					<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="DOM.html">DOM</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="$CompositeElement.html">$CompositeElement</a>
						</li>
						
						<li>
							<a href="$Element.html">$Element</a>
						</li>
						
						<li>
							<a href="$Node.html">$Node</a>
						</li>
						
						<li>
							<a href="$NullElement.html">$NullElement</a>
						</li>
						

					</ul>
				</li>
				
			</ul>
		</div>
	</div>

	<div class="row-fluid">

		
			<div class="span12">
				
				<div id="main">
					


		<h1 class="page-title">Source: Node.events.js</h1>
    
    <section>
        <article>
            <pre class="sunlight-highlight-javascript ">define(["Node", "Node.supports"], function($Node, $Element, SelectorMatcher, EventHandler, _forEach, _forOwn, _slice, _makeError) {
    "use strict";

    // DOM EVENTS
    // ----------

    (function() {
        var eventHooks = {},
            legacyCustomEventName = "dataavailable";

        /**
         * Bind a DOM event to the context
         * @param  {String}   type event type with optional selector
         * @param  {Array}    [props] event properties to pass to the callback function
         * @param  {Object}   [context] callback context
         * @param  {Function|String} callback event callback/property name
         * @return {$Node}
         * @example
         * // NOTICE: handler don't have e as the first argument
         * input.on("click", function() {...});
         * // NOTICE: event properties in event name
         * input.on("keydown", ["which", "altKey"], function(which, altKey) {...});
         */
        $Node.prototype.on = function(type, props, context, callback, /*INTERNAL*/once) {
            var node = this._node,
                eventType = typeof type,
                hook, handler, selector, index;

            if (eventType === "string") {
                index = type.indexOf(" ");

                if (~index) {
                    selector = type.substr(index + 1);
                    type = type.substr(0, index);
                }

                // handle optional props argument
                if (Object.prototype.toString.call(props) !== "[object Array]") {
                    once = callback;
                    callback = context;
                    context = props;
                    props = undefined;
                }

                // handle optional context argument
                if (typeof context !== "object") {
                    once = callback;
                    callback = context;
                    context = this;
                }

                if (once) {
                    callback = (function(thisPtr, originalCallback) {
                        return function() {
                            // remove event listener
                            thisPtr.off(handler.type, handler.context, callback);

                            return originalCallback.apply(this, arguments);
                        };
                    }(this, callback));
                }

                handler = EventHandler(type, selector, context, callback, props, this);
                handler.type = selector ? type + " " + selector : type;
                handler.callback = callback;
                handler.context = context;

                if (hook = eventHooks[type]) hook(handler);

                if (document.addEventListener) {
                    node.addEventListener(handler._type || type, handler, !!handler.capturing);
                } else {
                    // IE8 doesn't support onscroll on document level
                    if (this === DOM && type === "scroll") node = window;

                    node.attachEvent("on" + (handler._type || type), handler);
                }
                // store event entry
                this._listeners.push(handler);
            } else if (eventType === "object") {
                _forOwn(type, function(value, name) { this.on(name, value); }, this);
            } else {
                throw _makeError("on", this);
            }

            return this;
        };

        /**
         * Bind a DOM event to the context and the callback only fire once before being removed
         * @param  {String}   type type of event with optional selector to filter by
         * @param  {Array}    [props] event properties to pass to the callback function
         * @param  {Object}   [context] callback context
         * @param  {Function|String} callback event callback/property name
         * @return {$Node}
         */
        $Node.prototype.once = function() {
            var args = _slice(arguments);

            args.push(true);

            return $Node.prototype.on.apply(this, args);
        };

        /**
         * Unbind a DOM event from the context
         * @param  {String}          type type of event
         * @param  {Object}          [context] callback context
         * @param  {Function|String} [callback] event handler
         * @return {$Node}
         */
        $Node.prototype.off = function(type, context, callback) {
            if (typeof type !== "string") {
                throw _makeError("off", this);
            }

            if (arguments.length === 2) {
                callback = context;
                context = !callback ? undefined : this;
            }

            _forEach(this._listeners, function(handler, index, events) {
                var node = this._node;

                if (handler && type === handler.type && (!context || context === handler.context) && (!callback || callback === handler.callback)) {
                    type = handler._type || handler.type;

                    if (document.removeEventListener) {
                        node.removeEventListener(type, handler, !!handler.capturing);
                    } else {
                        // IE8 doesn't support onscroll on document level
                        if (this === DOM && type === "scroll") node = window;

                        node.detachEvent("on" + type, handler);
                    }

                    delete events[index];
                }
            }, this);

            return this;
        };

        /**
         * Triggers an event of specific type and executes it's default action if it exists
         * @param  {String} type type of event
         * @param  {Object} [detail] event details
         * @return {$Node}
         * @example
         * var domLink = DOM.find(".link");
         *
         * domLink.fire("focus");
         * // receive focus to the element
         * domLink.fire("custom:event", {x: 1, y: 2});
         * // trigger a custom:event on the element
         */
        $Node.prototype.fire = function(type, detail) {
            if (typeof type !== "string") {
                throw _makeError("fire", this);
            }

            var node = this._node,
                hook = eventHooks[type],
                handler = {},
                isCustomEvent, canContinue, event;

            if (hook) hook(handler);

            isCustomEvent = handler.custom || !this.supports("on" + type);

            if (document.createEvent) {
                event = document.createEvent("HTMLEvents");

                event.initEvent(handler._type || type, true, true);
                event.detail = detail;

                canContinue = node.dispatchEvent(event);
            } else {
                event = document.createEventObject();
                // store original event type
                event.srcUrn = isCustomEvent ? type : undefined;
                event.detail = detail;

                node.fireEvent("on" + (isCustomEvent ? legacyCustomEventName : handler._type || type), event);

                canContinue = event.returnValue !== false;
            }

            // Call a native DOM method on the target with the same name as the event
            // IE&lt;9 dies on focus/blur to hidden element
            if (canContinue && node[type] && (type !== "focus" && type !== "blur" || node.offsetWidth)) {
                // Prevent re-triggering of the same event
                EventHandler.veto = type;

                node[type]();

                EventHandler.veto = false;
            }

            return this;
        };

        // firefox doesn't support focusin/focusout events
        if ($Node.prototype.supports("onfocusin", "input")) {
            _forOwn({focus: "focusin", blur: "focusout"}, function(value, prop) {
                eventHooks[prop] = function(handler) { handler._type = value; };
            });
        } else {
            eventHooks.focus = eventHooks.blur = function(handler) {
                handler.capturing = true;
            };
        }

        if ($Node.prototype.supports("validity", "input")) {
            eventHooks.invalid = function(handler) {
                handler.capturing = true;
            };
        }

        if (document.attachEvent && !window.CSSKeyframesRule) {
            // input event fix via propertychange
            document.attachEvent("onfocusin", (function() {
                var legacyEventHandler = function() {
                        if (capturedNode && capturedNode.value !== capturedNodeValue) {
                            capturedNodeValue = capturedNode.value;
                            // trigger special event that bubbles
                            $Element(capturedNode).fire("input");
                        }
                    },
                    capturedNode, capturedNodeValue;

                if (window.addEventListener) {
                    // IE9 doesn't fire oninput when text is deleted, so use
                    // legacy onselectionchange event to detect such cases
                    // http://benalpert.com/2013/06/18/a-near-perfect-oninput-shim-for-ie-8-and-9.html
                    document.attachEvent("onselectionchange", legacyEventHandler);
                }

                return function() {
                    var target = window.event.srcElement,
                        type = target.type;

                    if (capturedNode) {
                        capturedNode.detachEvent("onpropertychange", legacyEventHandler);
                        capturedNode = undefined;
                    }

                    if (type === "text" || type === "password" || type === "textarea") {
                        (capturedNode = target).attachEvent("onpropertychange", legacyEventHandler);
                    }
                };
            })());

            if (!window.addEventListener) {
                // submit event bubbling fix
                document.attachEvent("onkeydown", function() {
                    var e = window.event,
                        target = e.srcElement,
                        form = target.form;

                    if (form && target.type !== "textarea" && e.keyCode === 13 && e.returnValue !== false) {
                        $Element(form).fire("submit");

                        return false;
                    }
                });

                document.attachEvent("onclick", (function() {
                    var handleSubmit = function() {
                            var form = window.event.srcElement;

                            form.detachEvent("onsubmit", handleSubmit);

                            $Element(form).fire("submit");

                            return false;
                        };

                    return function() {
                        var target = window.event.srcElement,
                            form = target.form;

                        if (form && target.type === "submit") {
                            form.attachEvent("onsubmit", handleSubmit);
                        }
                    };
                })());

                eventHooks.submit = function(handler) {
                    handler.custom = true;
                };
            }
        }
    }());
});
</pre>
        </article>
    </section>





				</div>

				<div class="clearfix"></div>
				<footer>
					
					
		<span class="jsdoc-message">
		Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.0</a>
		on Sun Sep 15 2013 12:46:22 GMT+0300 (FET) using the <a href="https://github.com/terryweiss/docstrap">DocStrap template</a>.
		</span>
				</footer>
			</div>

			
			<br clear="both">
		</div>

	</div>
	<script src="scripts/sunlight.js"></script>
	<script src="scripts/sunlight.javascript.js"></script>
	<script src="scripts/sunlight-plugin.doclinks.js"></script>
	<script src="scripts/sunlight-plugin.linenumbers.js"></script>
	<script src="scripts/sunlight-plugin.menu.js"></script>
	<script src="scripts/jquery.min.js"></script>
	<script src="scripts/jquery.scrollTo.js"></script>
	<script src="scripts/jquery.localScroll.js"></script>
	<script src="scripts/bootstrap-dropdown.js"></script>
	<script src="scripts/toc.js"></script>


	<script>  Sunlight.highlightAll({lineNumbers:false,  showMenu: true, enableDoclinks :true}); </script>

	<script>
		$( function () {
			$( "#toc" ).toc( {
				selectors   : "h1,h2,h3,h4",
				showAndHide : false,
				scrollTo    : 60
			} );
			$( "#toc>ul" ).addClass( "nav nav-pills nav-stacked" );
			$( "#main span[id^='toc']" ).addClass( "toc-shim" );

		} );
	</script>

	

</body>
</html>
